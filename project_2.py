# -*- coding: utf-8 -*-
"""Project 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1567JMMmSQE0wNk9yBaJp_c4zbf1DOEhU

Python Mandatory Project(Advance)
submitted by
# Nikhil (S5851)
"""

#importing the necessary libraries.
import seaborn as sns
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount("/content/drive")

#defining res1 as to read the excel file.
res1=pd.read_excel("/content/drive/MyDrive/housing.xlsx")
res1

"""**Data Description:**

The Data sets describes various aspects and details of the houses location and people residing inside them. The houses are located in California, USA.


1. Longitude: *A measurement of horizontal distance of house from west to east, higher longitude value = House resides towards extreme west. Numerical data type = Quantitative Data   i.e. Continuous Data.*

2. Latitude: *A measurement of vertical distance of house i.e.towards north, higher value = House resides towards north. Numerical data type = Quantitative Data, i.e, Continuous Data.*

3. Housing_median_age: *It presents Median age of a house. Numerical data type = Quantitative datatype,i.e.,Continuous Data.*

4. total_rooms: *Total number of rooms within a block. Numerical Data type = quantitative data, i.e. Discrete Data.*

5. total_bedrooms: *Total number of bedrooms within a block. Numerical Data type = Quantitative data, i.e. Discrete Data.*

6. population: *Total number of people residing within a block. Numerical Data type = quantitative data, i.e.,Discrete Data.*

7. households: *Total number of households,a group of people residing within a homeunit. Numerical Data type = Quantitative Data, i.e. Discrete data.*

8. median_income: *Median income of households within a block of houses. Numerical data type = Quantitative datatype, i.e.Continuous Data.*

9. median_house_value: *Median house value for households within a block. Numerical data type = Quantitative datatype,i.e.Continuous Data.*

10. Ocean_proximity: *Location of the house with respect to ocean level. Numerical data type = Categorical data i.e. Nominal Data.*

"""

#top 5 rows of the data
res1.head()

#Summary statistics of the dataframe
print(res1.describe())

"""1. What is the average median income of the data set and check the distribution of data using appropriate plots. Please explain the distribution of the plot."""

avg = res1["median_income"].mean() #finding mean
rounded = round(avg,2) #rounding the mean to 2 decimal
print(f"Average Median Income of the data set is: {rounded}.")


plt.figure(figsize=(4,5))
res1.hist(bins=50,figsize=(15,15), edgecolor="black") #Histogram to be used
plt.show()

"""Q2. Draw an appropriate plot to see the distribution of housing_median_age and explain your observations."""

plt.hist(res1["housing_median_age"],color='orange', edgecolor='crimson',bins =40) #outlires can be identify.
plt.title('Distribution of Housing Median Age')
plt.xlabel('Housing Median Age')
plt.ylabel('Frequency')
plt.show() #graph is symetric in nature

"""# Graph Representation:
*The graph looks symetric in nature.*

**Q3** Show with the help of visualization, how median_income and
median_house_values are related?
"""

plt.scatter(res1["median_house_value"], res1["median_income"],marker = 'o', edgecolor='b', facecolor = 'lightgreen')
plt.title("Median_house_value and Median_income")
plt.xlabel("median_house_value")
plt.ylabel("median_income")
plt.show()
# Median value of the house is directly proportional to the Median income of the house. Outlires can be identify.

"""# Graph Representation:
*Median value of the house is directly proportional to the Median income of the house. Outlires can also be identified.*

Q4. Create a data set by deleting the corresponding examples from the data set for which total_bedrooms are not available.
"""

res1[res1.isnull().any(axis=1)] #isnull gives the True value where null values are found else False. verticaly
drop_data=res1.dropna(subset = ["total_bedrooms"]) #dropna will drop the missing rows/col with null values.
print(drop_data)

"""Q5.Create a data set by filling the missing data with the mean value of the total_bedrooms in the original data set."""

avg = res1["total_bedrooms"].mean()
rounded = round(avg,2)
#print(f"Mean value is: {rounded}")
fillin_data = res1.fillna(rounded) #missing values NAN are replaced by mean of total_bedrooms.
x=fillin_data.loc[290]  #341
print(x)

"""Q6. Write a programming construct (create a user defined function) to calculate the median value of the data set wherever required."""

def median (x):   #define function called median
  sub = x.median() # sub will store the median value of the input parameter(x).
  return sub   #returning the function.'''

print(res1.median())  #returns Series containing the medians for each column.

"""Q7.  Plot latitude versus longitude and explain your observations."""

sns.scatterplot(x='latitude',y='longitude',hue='ocean_proximity',data=res1)
plt.show()
#decrease in longitude,latitude is increased.

"""# Graph Representation:
*As the longitude decreses, latitude is increased. Hence, it shows that latitude and longitude are not dependent on each other and are inversely proportional to each other.*

Q8. Create a data set for which the ocean_proximity is ‘Near ocean’.
"""

data=res1.loc[res1["ocean_proximity"]=="NEAR OCEAN"] #LOC will locate the position of respective name
data

"""Q9. Find the mean and median of the median income for the data set created in question 8."""

avg = res1["median_income"].mean()
rounded = round(avg,2)
print(f"Mean value is: {rounded}")
Median = res1["median_income"].median()
rounded = round(Median,2)
print("Median  value is", rounded)

"""Q10. Please create a new column named total_bedroom_size. If the total bedrooms is 10 or less, it should be quoted as small. If the total bedrooms is 11 or more but less than 1000, it should be medium, otherwise it should be considered large."""

requirements = [(res1['total_bedrooms'] <=10),  #parameters
              (res1['total_bedrooms'] >=11)&(res1['total_bedrooms'] <=1000),
              (res1['total_bedrooms'] > 1000)]

values = ["Small","Medium","Large"] #arguments

res1["total_bedroom_size"]=np.select(requirements,values)

res1

#new col has been added